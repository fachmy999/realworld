import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, e as element, a as space, t as text, b as claim_element, f as children, h as detach_dev, j as claim_space, g as claim_text, k as attr_dev, l as add_location, K as listen_dev, o as insert_dev, p as append_dev, q as set_data_dev, n as noop, L as destroy_each, C as empty, v as validate_store, c as component_subscribe, H as group_outros, z as transition_out, I as check_outros, y as transition_in, u as mount_component, A as destroy_component, M as update_keyed_each, N as outro_and_destroy_block } from './chunk.6414288c.js';
import { a as stores$1 } from './chunk.78ecd290.js';
import { p as post, d as del, g as get } from './chunk.11f50e20.js';

/* src/routes/_components/ArticleList/ArticlePreview.svelte generated by Svelte v3.12.1 */

const file = "src/routes/_components/ArticleList/ArticlePreview.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.tag = list[i];
	return child_ctx;
}

// (37:2) {#if user}
function create_if_block(ctx) {
	var div, button, i, t0, t1_value = ctx.article.favoritesCount + "", t1, button_class_value, dispose;

	const block = {
		c: function create() {
			div = element("div");
			button = element("button");
			i = element("i");
			t0 = space();
			t1 = text(t1_value);
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			button = claim_element(div_nodes, "BUTTON", { class: true }, false);
			var button_nodes = children(button);

			i = claim_element(button_nodes, "I", { class: true }, false);
			var i_nodes = children(i);

			i_nodes.forEach(detach_dev);
			t0 = claim_space(button_nodes);
			t1 = claim_text(button_nodes, t1_value);
			button_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(i, "class", "ion-heart");
			add_location(i, file, 39, 5, 1071);
			attr_dev(button, "class", button_class_value = "btn btn-sm " + (ctx.article.favorited ? "btn-primary" : "btn-outline-primary"));
			add_location(button, file, 38, 4, 952);
			attr_dev(div, "class", "pull-xs-right");
			add_location(div, file, 37, 3, 920);
			dispose = listen_dev(button, "click", ctx.toggleFavorite);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, button);
			append_dev(button, i);
			append_dev(button, t0);
			append_dev(button, t1);
		},

		p: function update(changed, ctx) {
			if ((changed.article) && t1_value !== (t1_value = ctx.article.favoritesCount + "")) {
				set_data_dev(t1, t1_value);
			}

			if ((changed.article) && button_class_value !== (button_class_value = "btn btn-sm " + (ctx.article.favorited ? "btn-primary" : "btn-outline-primary"))) {
				attr_dev(button, "class", button_class_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			dispose();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block.name, type: "if", source: "(37:2) {#if user}", ctx });
	return block;
}

// (51:3) {#each article.tagList as tag}
function create_each_block(ctx) {
	var li, t0_value = ctx.tag + "", t0, t1;

	const block = {
		c: function create() {
			li = element("li");
			t0 = text(t0_value);
			t1 = space();
			this.h();
		},

		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true }, false);
			var li_nodes = children(li);

			t0 = claim_text(li_nodes, t0_value);
			t1 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(li, "class", "tag-default tag-pill tag-outline");
			add_location(li, file, 51, 4, 1383);
		},

		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, t0);
			append_dev(li, t1);
		},

		p: function update(changed, ctx) {
			if ((changed.article) && t0_value !== (t0_value = ctx.tag + "")) {
				set_data_dev(t0, t0_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(li);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block.name, type: "each", source: "(51:3) {#each article.tagList as tag}", ctx });
	return block;
}

function create_fragment(ctx) {
	var div2, div1, a0, img, img_src_value, img_alt_value, a0_href_value, t0, div0, a1, t1_value = ctx.article.author.username + "", t1, a1_href_value, t2, span0, t3_value = new Date(ctx.article.createdAt).toDateString() + "", t3, t4, t5, a2, h1, t6_value = ctx.article.title + "", t6, t7, p, t8_value = ctx.article.description + "", t8, t9, span1, t10, t11, ul, a2_href_value;

	var if_block = (ctx.user) && create_if_block(ctx);

	let each_value = ctx.article.tagList;

	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div2 = element("div");
			div1 = element("div");
			a0 = element("a");
			img = element("img");
			t0 = space();
			div0 = element("div");
			a1 = element("a");
			t1 = text(t1_value);
			t2 = space();
			span0 = element("span");
			t3 = text(t3_value);
			t4 = space();
			if (if_block) if_block.c();
			t5 = space();
			a2 = element("a");
			h1 = element("h1");
			t6 = text(t6_value);
			t7 = space();
			p = element("p");
			t8 = text(t8_value);
			t9 = space();
			span1 = element("span");
			t10 = text("Read more...");
			t11 = space();
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}
			this.h();
		},

		l: function claim(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true }, false);
			var div2_nodes = children(div2);

			div1 = claim_element(div2_nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			a0 = claim_element(div1_nodes, "A", { href: true }, false);
			var a0_nodes = children(a0);

			img = claim_element(a0_nodes, "IMG", { src: true, alt: true }, false);
			var img_nodes = children(img);

			img_nodes.forEach(detach_dev);
			a0_nodes.forEach(detach_dev);
			t0 = claim_space(div1_nodes);

			div0 = claim_element(div1_nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			a1 = claim_element(div0_nodes, "A", { class: true, href: true }, false);
			var a1_nodes = children(a1);

			t1 = claim_text(a1_nodes, t1_value);
			a1_nodes.forEach(detach_dev);
			t2 = claim_space(div0_nodes);

			span0 = claim_element(div0_nodes, "SPAN", { class: true }, false);
			var span0_nodes = children(span0);

			t3 = claim_text(span0_nodes, t3_value);
			span0_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			t4 = claim_space(div1_nodes);
			if (if_block) if_block.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			t5 = claim_space(div2_nodes);

			a2 = claim_element(div2_nodes, "A", { href: true, rel: true, class: true }, false);
			var a2_nodes = children(a2);

			h1 = claim_element(a2_nodes, "H1", {}, false);
			var h1_nodes = children(h1);

			t6 = claim_text(h1_nodes, t6_value);
			h1_nodes.forEach(detach_dev);
			t7 = claim_space(a2_nodes);

			p = claim_element(a2_nodes, "P", {}, false);
			var p_nodes = children(p);

			t8 = claim_text(p_nodes, t8_value);
			p_nodes.forEach(detach_dev);
			t9 = claim_space(a2_nodes);

			span1 = claim_element(a2_nodes, "SPAN", {}, false);
			var span1_nodes = children(span1);

			t10 = claim_text(span1_nodes, "Read more...");
			span1_nodes.forEach(detach_dev);
			t11 = claim_space(a2_nodes);

			ul = claim_element(a2_nodes, "UL", { class: true }, false);
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			a2_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(img, "src", img_src_value = ctx.article.author.image);
			attr_dev(img, "alt", img_alt_value = ctx.article.author.username);
			add_location(img, file, 25, 3, 618);
			attr_dev(a0, "href", a0_href_value = "/profile/@" + ctx.article.author.username);
			add_location(a0, file, 24, 2, 568);
			attr_dev(a1, "class", "author");
			attr_dev(a1, "href", a1_href_value = "/profile/@" + ctx.article.author.username);
			add_location(a1, file, 29, 3, 715);
			attr_dev(span0, "class", "date");
			add_location(span0, file, 31, 3, 814);
			attr_dev(div0, "class", "info");
			add_location(div0, file, 28, 2, 693);
			attr_dev(div1, "class", "article-meta");
			add_location(div1, file, 23, 1, 539);
			add_location(h1, file, 46, 2, 1237);
			add_location(p, file, 47, 2, 1264);
			add_location(span1, file, 48, 2, 1295);
			attr_dev(ul, "class", "tag-list");
			add_location(ul, file, 49, 2, 1323);
			attr_dev(a2, "href", a2_href_value = "/article/" + ctx.article.slug);
			attr_dev(a2, "rel", "prefetch");
			attr_dev(a2, "class", "preview-link");
			add_location(a2, file, 45, 1, 1164);
			attr_dev(div2, "class", "article-preview");
			add_location(div2, file, 22, 0, 508);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div1);
			append_dev(div1, a0);
			append_dev(a0, img);
			append_dev(div1, t0);
			append_dev(div1, div0);
			append_dev(div0, a1);
			append_dev(a1, t1);
			append_dev(div0, t2);
			append_dev(div0, span0);
			append_dev(span0, t3);
			append_dev(div1, t4);
			if (if_block) if_block.m(div1, null);
			append_dev(div2, t5);
			append_dev(div2, a2);
			append_dev(a2, h1);
			append_dev(h1, t6);
			append_dev(a2, t7);
			append_dev(a2, p);
			append_dev(p, t8);
			append_dev(a2, t9);
			append_dev(a2, span1);
			append_dev(span1, t10);
			append_dev(a2, t11);
			append_dev(a2, ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}
		},

		p: function update(changed, ctx) {
			if ((changed.article) && img_src_value !== (img_src_value = ctx.article.author.image)) {
				attr_dev(img, "src", img_src_value);
			}

			if ((changed.article) && img_alt_value !== (img_alt_value = ctx.article.author.username)) {
				attr_dev(img, "alt", img_alt_value);
			}

			if ((changed.article) && a0_href_value !== (a0_href_value = "/profile/@" + ctx.article.author.username)) {
				attr_dev(a0, "href", a0_href_value);
			}

			if ((changed.article) && t1_value !== (t1_value = ctx.article.author.username + "")) {
				set_data_dev(t1, t1_value);
			}

			if ((changed.article) && a1_href_value !== (a1_href_value = "/profile/@" + ctx.article.author.username)) {
				attr_dev(a1, "href", a1_href_value);
			}

			if ((changed.article) && t3_value !== (t3_value = new Date(ctx.article.createdAt).toDateString() + "")) {
				set_data_dev(t3, t3_value);
			}

			if (ctx.user) {
				if (if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(div1, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if ((changed.article) && t6_value !== (t6_value = ctx.article.title + "")) {
				set_data_dev(t6, t6_value);
			}

			if ((changed.article) && t8_value !== (t8_value = ctx.article.description + "")) {
				set_data_dev(t8, t8_value);
			}

			if (changed.article) {
				each_value = ctx.article.tagList;

				let i;
				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}
				each_blocks.length = each_value.length;
			}

			if ((changed.article) && a2_href_value !== (a2_href_value = "/article/" + ctx.article.slug)) {
				attr_dev(a2, "href", a2_href_value);
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div2);
			}

			if (if_block) if_block.d();

			destroy_each(each_blocks, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment.name, type: "component", source: "", ctx });
	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { article, user } = $$props;

	async function toggleFavorite() {
		// optimistic UI
		if (article.favorited) {
			$$invalidate('article', article.favoritesCount -= 1, article);
			$$invalidate('article', article.favorited = false, article);
		} else {
			$$invalidate('article', article.favoritesCount += 1, article);
			$$invalidate('article', article.favorited = true, article);
		}

		($$invalidate('article', { article } = await (article.favorited
			? post(`articles/${article.slug}/favorite`, null, user && user.token)
			: del(`articles/${article.slug}/favorite`, user && user.token)), article));
	}

	const writable_props = ['article', 'user'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<ArticlePreview> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('article' in $$props) $$invalidate('article', article = $$props.article);
		if ('user' in $$props) $$invalidate('user', user = $$props.user);
	};

	$$self.$capture_state = () => {
		return { article, user };
	};

	$$self.$inject_state = $$props => {
		if ('article' in $$props) $$invalidate('article', article = $$props.article);
		if ('user' in $$props) $$invalidate('user', user = $$props.user);
	};

	return { article, user, toggleFavorite };
}

class ArticlePreview extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, ["article", "user"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "ArticlePreview", options, id: create_fragment.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.article === undefined && !('article' in props)) {
			console.warn("<ArticlePreview> was created without expected prop 'article'");
		}
		if (ctx.user === undefined && !('user' in props)) {
			console.warn("<ArticlePreview> was created without expected prop 'user'");
		}
	}

	get article() {
		throw new Error("<ArticlePreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set article(value) {
		throw new Error("<ArticlePreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get user() {
		throw new Error("<ArticlePreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set user(value) {
		throw new Error("<ArticlePreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/_components/ArticleList/ListPagination.svelte generated by Svelte v3.12.1 */

const file$1 = "src/routes/_components/ArticleList/ListPagination.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.v = list[i];
	return child_ctx;
}

// (15:0) {#if articlesCount > 10}
function create_if_block$1(ctx) {
	var nav, ul;

	let each_value = ctx.range;

	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			nav = element("nav");
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}
			this.h();
		},

		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {}, false);
			var nav_nodes = children(nav);

			ul = claim_element(nav_nodes, "UL", { class: true }, false);
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(ul, "class", "pagination");
			add_location(ul, file$1, 16, 2, 218);
			add_location(nav, file$1, 15, 1, 210);
		},

		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}
		},

		p: function update(changed, ctx) {
			if (changed.range || changed.page) {
				each_value = ctx.range;

				let i;
				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}
				each_blocks.length = each_value.length;
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(nav);
			}

			destroy_each(each_blocks, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block$1.name, type: "if", source: "(15:0) {#if articlesCount > 10}", ctx });
	return block;
}

// (19:3) {#each range as v}
function create_each_block$1(ctx) {
	var li, a, t0_value = ctx.v + 1 + "", t0, a_href_value, t1, li_class_value;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			this.h();
		},

		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true }, false);
			var li_nodes = children(li);

			a = claim_element(li_nodes, "A", { class: true, href: true }, false);
			var a_nodes = children(a);

			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(a, "class", "page-link");
			attr_dev(a, "href", a_href_value = "/" + (ctx.v ? ctx.v + 1 : ''));
			add_location(a, file$1, 20, 5, 325);
			attr_dev(li, "class", li_class_value = "page-item " + (ctx.v === ctx.page ? "active": ""));
			add_location(li, file$1, 19, 4, 269);
		},

		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
		},

		p: function update(changed, ctx) {
			if ((changed.range) && t0_value !== (t0_value = ctx.v + 1 + "")) {
				set_data_dev(t0, t0_value);
			}

			if ((changed.range) && a_href_value !== (a_href_value = "/" + (ctx.v ? ctx.v + 1 : ''))) {
				attr_dev(a, "href", a_href_value);
			}

			if ((changed.range || changed.page) && li_class_value !== (li_class_value = "page-item " + (ctx.v === ctx.page ? "active": ""))) {
				attr_dev(li, "class", li_class_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(li);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block$1.name, type: "each", source: "(19:3) {#each range as v}", ctx });
	return block;
}

function create_fragment$1(ctx) {
	var if_block_anchor;

	var if_block = (ctx.articlesCount > 10) && create_if_block$1(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},

		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},

		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},

		p: function update(changed, ctx) {
			if (ctx.articlesCount > 10) {
				if (if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);

			if (detaching) {
				detach_dev(if_block_anchor);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$1.name, type: "component", source: "", ctx });
	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { articlesCount, page } = $$props;

	let range;

	const writable_props = ['articlesCount', 'page'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<ListPagination> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('articlesCount' in $$props) $$invalidate('articlesCount', articlesCount = $$props.articlesCount);
		if ('page' in $$props) $$invalidate('page', page = $$props.page);
	};

	$$self.$capture_state = () => {
		return { articlesCount, page, range };
	};

	$$self.$inject_state = $$props => {
		if ('articlesCount' in $$props) $$invalidate('articlesCount', articlesCount = $$props.articlesCount);
		if ('page' in $$props) $$invalidate('page', page = $$props.page);
		if ('range' in $$props) $$invalidate('range', range = $$props.range);
	};

	$$self.$$.update = ($$dirty = { articlesCount: 1, range: 1 }) => {
		if ($$dirty.articlesCount || $$dirty.range) { {
				$$invalidate('range', range = []);
				for (let i = 0; i < Math.ceil(articlesCount / 10); ++i) {
					range.push(i);
				}
			} }
	};

	return { articlesCount, page, range };
}

class ListPagination extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, ["articlesCount", "page"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "ListPagination", options, id: create_fragment$1.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.articlesCount === undefined && !('articlesCount' in props)) {
			console.warn("<ListPagination> was created without expected prop 'articlesCount'");
		}
		if (ctx.page === undefined && !('page' in props)) {
			console.warn("<ListPagination> was created without expected prop 'page'");
		}
	}

	get articlesCount() {
		throw new Error("<ListPagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set articlesCount(value) {
		throw new Error("<ListPagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get page() {
		throw new Error("<ListPagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set page(value) {
		throw new Error("<ListPagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/_components/ArticleList/index.svelte generated by Svelte v3.12.1 */

const file$2 = "src/routes/_components/ArticleList/index.svelte";

function get_each_context$2(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.article = list[i];
	return child_ctx;
}

// (53:0) {:else}
function create_else_block_1(ctx) {
	var div, t;

	const block = {
		c: function create() {
			div = element("div");
			t = text("Loading...");
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			t = claim_text(div_nodes, "Loading...");
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "class", "article-preview");
			add_location(div, file$2, 53, 1, 1332);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},

		p: noop,
		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_else_block_1.name, type: "else", source: "(53:0) {:else}", ctx });
	return block;
}

// (39:0) {#if articles}
function create_if_block$2(ctx) {
	var current_block_type_index, if_block, if_block_anchor, current;

	var if_block_creators = [
		create_if_block_1,
		create_else_block
	];

	var if_blocks = [];

	function select_block_type_1(changed, ctx) {
		if (ctx.articles.length === 0) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(null, ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},

		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},

		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(changed, ctx);
			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				group_outros();
				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});
				check_outros();

				if_block = if_blocks[current_block_type_index];
				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}
				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},

		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},

		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);

			if (detaching) {
				detach_dev(if_block_anchor);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block$2.name, type: "if", source: "(39:0) {#if articles}", ctx });
	return block;
}

// (44:1) {:else}
function create_else_block(ctx) {
	var div, each_blocks = [], each_1_lookup = new Map(), t, current;

	let each_value = ctx.articles;

	const get_key = ctx => ctx.article.slug;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$2(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$2(key, child_ctx));
	}

	var listpagination = new ListPagination({
		props: {
		articlesCount: ctx.articlesCount,
		page: parseInt(ctx.$page.params.user, 10)
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			listpagination.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {}, false);
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			t = claim_space(div_nodes);
			listpagination.$$.fragment.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			add_location(div, file$2, 44, 2, 1112);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			append_dev(div, t);
			mount_component(listpagination, div, null);
			current = true;
		},

		p: function update(changed, ctx) {
			const each_value = ctx.articles;

			group_outros();
			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$2, t, get_each_context$2);
			check_outros();

			var listpagination_changes = {};
			if (changed.articlesCount) listpagination_changes.articlesCount = ctx.articlesCount;
			if (changed.$page) listpagination_changes.page = parseInt(ctx.$page.params.user, 10);
			listpagination.$set(listpagination_changes);
		},

		i: function intro(local) {
			if (current) return;
			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(listpagination.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(listpagination.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			destroy_component(listpagination);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_else_block.name, type: "else", source: "(44:1) {:else}", ctx });
	return block;
}

// (40:1) {#if articles.length === 0}
function create_if_block_1(ctx) {
	var div, t;

	const block = {
		c: function create() {
			div = element("div");
			t = text("No articles are here... yet.");
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			t = claim_text(div_nodes, "No articles are here... yet.");
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "class", "article-preview");
			add_location(div, file$2, 40, 2, 1030);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},

		p: noop,
		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_1.name, type: "if", source: "(40:1) {#if articles.length === 0}", ctx });
	return block;
}

// (46:3) {#each articles as article (article.slug)}
function create_each_block$2(key_1, ctx) {
	var first, current;

	var articlepreview = new ArticlePreview({
		props: {
		article: ctx.article,
		user: ctx.$session.user
	},
		$$inline: true
	});

	const block = {
		key: key_1,

		first: null,

		c: function create() {
			first = empty();
			articlepreview.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			first = empty();
			articlepreview.$$.fragment.l(nodes);
			this.h();
		},

		h: function hydrate() {
			this.first = first;
		},

		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);
			mount_component(articlepreview, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var articlepreview_changes = {};
			if (changed.articles) articlepreview_changes.article = ctx.article;
			if (changed.$session) articlepreview_changes.user = ctx.$session.user;
			articlepreview.$set(articlepreview_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(articlepreview.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(articlepreview.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(first);
			}

			destroy_component(articlepreview, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block$2.name, type: "each", source: "(46:3) {#each articles as article (article.slug)}", ctx });
	return block;
}

function create_fragment$2(ctx) {
	var current_block_type_index, if_block, if_block_anchor, current;

	var if_block_creators = [
		create_if_block$2,
		create_else_block_1
	];

	var if_blocks = [];

	function select_block_type(changed, ctx) {
		if (ctx.articles) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(null, ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},

		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},

		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(changed, ctx);
			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				group_outros();
				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});
				check_outros();

				if_block = if_blocks[current_block_type_index];
				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}
				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},

		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},

		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);

			if (detaching) {
				detach_dev(if_block_anchor);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$2.name, type: "component", source: "", ctx });
	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let $session, $page;

	

	let { tab, username = false, favorites = false, tag, p } = $$props;

	const { session, page } = stores$1(); validate_store(session, 'session'); component_subscribe($$self, session, $$value => { $session = $$value; $$invalidate('$session', $session); }); validate_store(page, 'page'); component_subscribe($$self, page, $$value => { $page = $$value; $$invalidate('$page', $page); });

	let query;
	let articles;
	let articlesCount;

	async function getData() {
		$$invalidate('articles', articles = null);

		// TODO do we need some error handling here?
		($$invalidate('articles', { articles, articlesCount } = await get(query, $session.user && $session.user.token), articles, $$invalidate('articlesCount', articlesCount)));
	}

	const writable_props = ['tab', 'username', 'favorites', 'tag', 'p'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Index> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('tab' in $$props) $$invalidate('tab', tab = $$props.tab);
		if ('username' in $$props) $$invalidate('username', username = $$props.username);
		if ('favorites' in $$props) $$invalidate('favorites', favorites = $$props.favorites);
		if ('tag' in $$props) $$invalidate('tag', tag = $$props.tag);
		if ('p' in $$props) $$invalidate('p', p = $$props.p);
	};

	$$self.$capture_state = () => {
		return { tab, username, favorites, tag, p, query, articles, articlesCount, $session, $page };
	};

	$$self.$inject_state = $$props => {
		if ('tab' in $$props) $$invalidate('tab', tab = $$props.tab);
		if ('username' in $$props) $$invalidate('username', username = $$props.username);
		if ('favorites' in $$props) $$invalidate('favorites', favorites = $$props.favorites);
		if ('tag' in $$props) $$invalidate('tag', tag = $$props.tag);
		if ('p' in $$props) $$invalidate('p', p = $$props.p);
		if ('query' in $$props) $$invalidate('query', query = $$props.query);
		if ('articles' in $$props) $$invalidate('articles', articles = $$props.articles);
		if ('articlesCount' in $$props) $$invalidate('articlesCount', articlesCount = $$props.articlesCount);
		if ('$session' in $$props) session.set($session);
		if ('$page' in $$props) page.set($page);
	};

	$$self.$$.update = ($$dirty = { tab: 1, p: 1, tag: 1, favorites: 1, username: 1, query: 1 }) => {
		if ($$dirty.tab || $$dirty.p || $$dirty.tag || $$dirty.favorites || $$dirty.username) { {
				const endpoint = tab === 'feed' ? 'articles/feed' : 'articles';
				const page_size = tab === 'feed' ? 5 : 10;
		
				let params = `limit=${page_size}&offset=${(p - 1) * page_size}`;
				if (tab === 'tag') params += `&tag=${tag}`;
				if (tab === 'profile') params += `&${favorites ? 'favorited' : 'author'}=${encodeURIComponent(username)}`;
		
				$$invalidate('query', query = `${endpoint}?${params}`);
			} }
		if ($$dirty.query) { query && getData(); }
	};

	return {
		tab,
		username,
		favorites,
		tag,
		p,
		session,
		page,
		articles,
		articlesCount,
		$session,
		$page
	};
}

class Index extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, ["tab", "username", "favorites", "tag", "p"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Index", options, id: create_fragment$2.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.tab === undefined && !('tab' in props)) {
			console.warn("<Index> was created without expected prop 'tab'");
		}
		if (ctx.tag === undefined && !('tag' in props)) {
			console.warn("<Index> was created without expected prop 'tag'");
		}
		if (ctx.p === undefined && !('p' in props)) {
			console.warn("<Index> was created without expected prop 'p'");
		}
	}

	get tab() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tab(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get username() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set username(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get favorites() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set favorites(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tag() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tag(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get p() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set p(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { Index as A };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmsuNTJiOGI5NDUuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yb3V0ZXMvX2NvbXBvbmVudHMvQXJ0aWNsZUxpc3QvQXJ0aWNsZVByZXZpZXcuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9fY29tcG9uZW50cy9BcnRpY2xlTGlzdC9MaXN0UGFnaW5hdGlvbi5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL19jb21wb25lbnRzL0FydGljbGVMaXN0L2luZGV4LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuXHRpbXBvcnQgKiBhcyBhcGkgZnJvbSAnYXBpLmpzJztcblxuXHRleHBvcnQgbGV0IGFydGljbGU7XG5cdGV4cG9ydCBsZXQgdXNlcjtcblxuXHRhc3luYyBmdW5jdGlvbiB0b2dnbGVGYXZvcml0ZSgpIHtcblx0XHQvLyBvcHRpbWlzdGljIFVJXG5cdFx0aWYgKGFydGljbGUuZmF2b3JpdGVkKSB7XG5cdFx0XHRhcnRpY2xlLmZhdm9yaXRlc0NvdW50IC09IDE7XG5cdFx0XHRhcnRpY2xlLmZhdm9yaXRlZCA9IGZhbHNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhcnRpY2xlLmZhdm9yaXRlc0NvdW50ICs9IDE7XG5cdFx0XHRhcnRpY2xlLmZhdm9yaXRlZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0KHsgYXJ0aWNsZSB9ID0gYXdhaXQgKGFydGljbGUuZmF2b3JpdGVkXG5cdFx0XHQ/IGFwaS5wb3N0KGBhcnRpY2xlcy8ke2FydGljbGUuc2x1Z30vZmF2b3JpdGVgLCBudWxsLCB1c2VyICYmIHVzZXIudG9rZW4pXG5cdFx0XHQ6IGFwaS5kZWwoYGFydGljbGVzLyR7YXJ0aWNsZS5zbHVnfS9mYXZvcml0ZWAsIHVzZXIgJiYgdXNlci50b2tlbikpKTtcblx0fVxuPC9zY3JpcHQ+XG5cbjxkaXYgY2xhc3M9XCJhcnRpY2xlLXByZXZpZXdcIj5cblx0PGRpdiBjbGFzcz1cImFydGljbGUtbWV0YVwiPlxuXHRcdDxhIGhyZWY9Jy9wcm9maWxlL0B7YXJ0aWNsZS5hdXRob3IudXNlcm5hbWV9Jz5cblx0XHRcdDxpbWcgc3JjPXthcnRpY2xlLmF1dGhvci5pbWFnZX0gYWx0PXthcnRpY2xlLmF1dGhvci51c2VybmFtZX0gLz5cblx0XHQ8L2E+XG5cblx0XHQ8ZGl2IGNsYXNzPVwiaW5mb1wiPlxuXHRcdFx0PGEgY2xhc3M9XCJhdXRob3JcIiBocmVmPScvcHJvZmlsZS9Ae2FydGljbGUuYXV0aG9yLnVzZXJuYW1lfSc+IHthcnRpY2xlLmF1dGhvci51c2VybmFtZX1cblx0XHRcdDwvYT5cblx0XHRcdDxzcGFuIGNsYXNzPVwiZGF0ZVwiPlxuXHRcdFx0XHR7bmV3IERhdGUoYXJ0aWNsZS5jcmVhdGVkQXQpLnRvRGF0ZVN0cmluZygpfVxuXHRcdFx0PC9zcGFuPlxuXHRcdDwvZGl2PlxuXG5cdFx0eyNpZiB1c2VyfVxuXHRcdFx0PGRpdiBjbGFzcz1cInB1bGwteHMtcmlnaHRcIj5cblx0XHRcdFx0PGJ1dHRvbiBjbGFzcz0nYnRuIGJ0bi1zbSB7YXJ0aWNsZS5mYXZvcml0ZWQgPyBcImJ0bi1wcmltYXJ5XCIgOiBcImJ0bi1vdXRsaW5lLXByaW1hcnlcIn0nIG9uOmNsaWNrPXt0b2dnbGVGYXZvcml0ZX0+XG5cdFx0XHRcdFx0PGkgY2xhc3M9XCJpb24taGVhcnRcIj48L2k+IHthcnRpY2xlLmZhdm9yaXRlc0NvdW50fVxuXHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdDwvZGl2PlxuXHRcdHsvaWZ9XG5cdDwvZGl2PlxuXG5cdDxhIGhyZWY9Jy9hcnRpY2xlL3thcnRpY2xlLnNsdWd9JyByZWw9J3ByZWZldGNoJyBjbGFzcz1cInByZXZpZXctbGlua1wiPlxuXHRcdDxoMT57YXJ0aWNsZS50aXRsZX08L2gxPlxuXHRcdDxwPnthcnRpY2xlLmRlc2NyaXB0aW9ufTwvcD5cblx0XHQ8c3Bhbj5SZWFkIG1vcmUuLi48L3NwYW4+XG5cdFx0PHVsIGNsYXNzPVwidGFnLWxpc3RcIj5cblx0XHRcdHsjZWFjaCBhcnRpY2xlLnRhZ0xpc3QgYXMgdGFnfVxuXHRcdFx0XHQ8bGkgY2xhc3M9XCJ0YWctZGVmYXVsdCB0YWctcGlsbCB0YWctb3V0bGluZVwiPlxuXHRcdFx0XHRcdHt0YWd9XG5cdFx0XHRcdDwvbGk+XG5cdFx0XHR7L2VhY2h9XG5cdFx0PC91bD5cblx0PC9hPlxuPC9kaXY+IiwiPHNjcmlwdD5cblx0ZXhwb3J0IGxldCBhcnRpY2xlc0NvdW50O1xuXHRleHBvcnQgbGV0IHBhZ2U7XG5cblx0bGV0IHJhbmdlO1xuXG5cdCQ6IHtcblx0XHRyYW5nZSA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5jZWlsKGFydGljbGVzQ291bnQgLyAxMCk7ICsraSkge1xuXHRcdFx0cmFuZ2UucHVzaChpKTtcblx0XHR9XG5cdH1cbjwvc2NyaXB0PlxuXG57I2lmIGFydGljbGVzQ291bnQgPiAxMH1cblx0PG5hdj5cblx0XHQ8dWwgY2xhc3M9XCJwYWdpbmF0aW9uXCI+XG5cblx0XHRcdHsjZWFjaCByYW5nZSBhcyB2fVxuXHRcdFx0XHQ8bGkgY2xhc3M9J3BhZ2UtaXRlbSB7diA9PT0gcGFnZSA/IFwiYWN0aXZlXCI6IFwiXCJ9Jz5cblx0XHRcdFx0XHQ8YSBjbGFzcz1cInBhZ2UtbGlua1wiIGhyZWY9XCIve3YgPyB2ICsgMSA6ICcnfVwiPnt2ICsgMX08L2E+XG5cdFx0XHRcdDwvbGk+XG5cdFx0XHR7L2VhY2h9XG5cdFx0PC91bD5cblx0PC9uYXY+XG57L2lmfSIsIjxzY3JpcHQ+XG5cdGltcG9ydCB7IHN0b3JlcyB9IGZyb20gJ0BzYXBwZXIvYXBwJztcblx0aW1wb3J0IEFydGljbGVQcmV2aWV3IGZyb20gJy4vQXJ0aWNsZVByZXZpZXcuc3ZlbHRlJztcblx0aW1wb3J0IExpc3RQYWdpbmF0aW9uIGZyb20gJy4vTGlzdFBhZ2luYXRpb24uc3ZlbHRlJztcblx0aW1wb3J0ICogYXMgYXBpIGZyb20gJ2FwaS5qcyc7XG5cblx0ZXhwb3J0IGxldCB0YWIsIHVzZXJuYW1lID0gZmFsc2U7XG5cdGV4cG9ydCBsZXQgZmF2b3JpdGVzID0gZmFsc2U7XG5cdGV4cG9ydCBsZXQgdGFnO1xuXHRleHBvcnQgbGV0IHA7XG5cblx0Y29uc3QgeyBzZXNzaW9uLCBwYWdlIH0gPSBzdG9yZXMoKTtcblxuXHRsZXQgcXVlcnk7XG5cdGxldCBhcnRpY2xlcztcblx0bGV0IGFydGljbGVzQ291bnQ7XG5cblx0JDoge1xuXHRcdGNvbnN0IGVuZHBvaW50ID0gdGFiID09PSAnZmVlZCcgPyAnYXJ0aWNsZXMvZmVlZCcgOiAnYXJ0aWNsZXMnO1xuXHRcdGNvbnN0IHBhZ2Vfc2l6ZSA9IHRhYiA9PT0gJ2ZlZWQnID8gNSA6IDEwO1xuXG5cdFx0bGV0IHBhcmFtcyA9IGBsaW1pdD0ke3BhZ2Vfc2l6ZX0mb2Zmc2V0PSR7KHAgLSAxKSAqIHBhZ2Vfc2l6ZX1gO1xuXHRcdGlmICh0YWIgPT09ICd0YWcnKSBwYXJhbXMgKz0gYCZ0YWc9JHt0YWd9YDtcblx0XHRpZiAodGFiID09PSAncHJvZmlsZScpIHBhcmFtcyArPSBgJiR7ZmF2b3JpdGVzID8gJ2Zhdm9yaXRlZCcgOiAnYXV0aG9yJ309JHtlbmNvZGVVUklDb21wb25lbnQodXNlcm5hbWUpfWA7XG5cblx0XHRxdWVyeSA9IGAke2VuZHBvaW50fT8ke3BhcmFtc31gO1xuXHR9XG5cblx0JDogcXVlcnkgJiYgZ2V0RGF0YSgpO1xuXG5cdGFzeW5jIGZ1bmN0aW9uIGdldERhdGEoKSB7XG5cdFx0YXJ0aWNsZXMgPSBudWxsO1xuXG5cdFx0Ly8gVE9ETyBkbyB3ZSBuZWVkIHNvbWUgZXJyb3IgaGFuZGxpbmcgaGVyZT9cblx0XHQoeyBhcnRpY2xlcywgYXJ0aWNsZXNDb3VudCB9ID0gYXdhaXQgYXBpLmdldChxdWVyeSwgJHNlc3Npb24udXNlciAmJiAkc2Vzc2lvbi51c2VyLnRva2VuKSk7XG5cdH1cbjwvc2NyaXB0PlxuXG57I2lmIGFydGljbGVzfVxuXHR7I2lmIGFydGljbGVzLmxlbmd0aCA9PT0gMH1cblx0XHQ8ZGl2IGNsYXNzPVwiYXJ0aWNsZS1wcmV2aWV3XCI+XG5cdFx0XHRObyBhcnRpY2xlcyBhcmUgaGVyZS4uLiB5ZXQuXG5cdFx0PC9kaXY+XG5cdHs6ZWxzZX1cblx0XHQ8ZGl2PlxuXHRcdFx0eyNlYWNoIGFydGljbGVzIGFzIGFydGljbGUgKGFydGljbGUuc2x1Zyl9XG5cdFx0XHRcdDxBcnRpY2xlUHJldmlldyB7YXJ0aWNsZX0gdXNlcj17JHNlc3Npb24udXNlcn0vPlxuXHRcdFx0ey9lYWNofVxuXG5cdFx0XHQ8TGlzdFBhZ2luYXRpb24ge2FydGljbGVzQ291bnR9IHBhZ2U9e3BhcnNlSW50KCRwYWdlLnBhcmFtcy51c2VyLCAxMCl9ICAvPlxuXHRcdDwvZGl2PlxuXHR7L2lmfVxuezplbHNlfVxuXHQ8ZGl2IGNsYXNzPVwiYXJ0aWNsZS1wcmV2aWV3XCI+TG9hZGluZy4uLjwvZGl2Plxuey9pZn0iXSwibmFtZXMiOlsiYXBpLnBvc3QiLCJhcGkuZGVsIiwic3RvcmVzIiwiYXBpLmdldCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozt3Q0F1Q2dDLE9BQU8sQ0FBQyxjQUFjOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUVBRHZCLE9BQU8sQ0FBQyxTQUFTLEdBQUcsYUFBYSxHQUFHLHFCQUFxQjs7Ozs2Q0FBYSxjQUFjOzs7Ozs7Ozs7Ozs7eURBQ25GLE9BQU8sQ0FBQyxjQUFjOzs7OzhGQUR2QixPQUFPLENBQUMsU0FBUyxHQUFHLGFBQWEsR0FBRyxxQkFBcUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7d0JBY2xGLEdBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3lEQUFILEdBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7b0dBdkJ5RCxPQUFPLENBQUMsTUFBTSxDQUFDLFFBQVEsZ0RBR3BGLElBQUksSUFBSSxLQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxZQUFZLEVBQUUsMENBY3hDLE9BQU8sQ0FBQyxLQUFLLGlDQUNkLE9BQU8sQ0FBQyxXQUFXOztxQkFYbEIsSUFBSTs7c0JBY0QsT0FBTyxDQUFDLE9BQU87Ozs7Z0NBQXBCOzs7Ozs7Ozs7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
